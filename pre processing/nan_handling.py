# -*- coding: utf-8 -*-
"""NaN_handling.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Rz0QVxXWWtkSUA9RvwURDFur7HgZQXPr
"""

from google.colab import drive
drive.mount('/content/drive')

#!pip install pyspark

import pandas as pd
import gc
import os
import matplotlib.pyplot as plt
import numpy as np
import gzip
os.chdir('/content/drive/MyDrive/Colab Notebooks/GitHub')
from labelling import label_ADNI

# Percorso del file GZIP
file_path = '/content/drive/MyDrive/PROJECT/chr_19_protein_NBCI_transp_filtered.csv.gz'

df = pd.read_csv(file_path, sep='\t', dtype=str)
df.set_index('ID', inplace=True)
df = df.astype(float)
df

# Percorso del file GZIP
file_path = '/content/drive/MyDrive/PROJECT/lookup_snpid_gene.csv.gz'

gene_snp = pd.read_csv(file_path, sep='\t', dtype=str)
gene_snp[gene_snp['gene_name'] == 'None'] = np.nan
gene_snp = gene_snp.set_index('snpid')
gene_snp = gene_snp.drop('Unnamed: 0', axis = 1)
gene_snp = gene_snp.dropna()
gene_snp

usefull_Gene = ['INSR', 'CLIP3', 'ALDH16A1', 'ERCC1', 'PPP1R13L','APOE']
max_nan_num = 0 
for i in usefull_Gene:
  for indice in gene_snp.index.tolist():
    if i == gene_snp.loc[indice]['gene_name']:
      print(gene_snp.loc[indice]['gene_name'])
      nan_num = df.loc[indice].isna().sum()
      if max_nan_num < nan_num:
        max_nan_num = nan_num

# rimuovere le righe che hanno un numero di NaN superiore a max_nan
df = df.dropna(thresh=(len(df.columns) - max_nan_num))
df = df.fillna(0)
gc.collect()

usefull_snps = df.index.tolist()
gene_snp = gene_snp.loc[usefull_snps]
gene_snp

file_adnimerge = '/content/drive/MyDrive/PROJECT/output_adnimerge.csv'
adnimerge = pd.read_csv(file_adnimerge)
adnimerge = adnimerge.set_index('Unnamed: 0')
adnimerge

# Fem primer amb PET 
adnimerge_lab = adnimerge.copy()
adnimerge_lab = label_ADNI(adnimerge_lab,'PET')

merged_df = pd.merge(df.T, adnimerge_lab, left_index=True, right_index=True)
merged_df

for i in merged_df.index:
    if i in adnimerge.index:
        merged_df.loc[i, 'PTGENDER'] = adnimerge.loc[i, 'PTGENDER']
        merged_df.loc[i, 'AGE'] = adnimerge.loc[i, 'AGE']

        
def gender_to_numeric(gender):
    if gender == 'Female':
        return 0
    elif gender == 'Male':
        return 1
    else:
        return None

merged_df['PTGENDER'] = merged_df['PTGENDER'].apply(gender_to_numeric)

# normalize with min-max scaling to estimate only one parameter and use it 

merged_df['AGE'] = pd.to_numeric(merged_df['AGE'], errors='coerce')
minimum = min(merged_df['AGE'])
maximum = max(merged_df['AGE'])
merged_df['AGE'] = (merged_df['AGE'] - minimum)/(maximum - minimum)
merged_df = merged_df.astype(float)
merged_df

y_col = merged_df.pop('y')
#merged_df = merged_df.drop('y', axis = 1)
merged_df['y'] = y_col
merged_df

merged_df.to_csv('/content/drive/MyDrive/PROJECT/chr_19_no_NaN.csv.gz', sep='\t', compression='gzip')

# Percorso del file GZIP
file_path = '/content/drive/MyDrive/PROJECT/chr_19_no_NaN.csv.gz'

df = pd.read_csv(file_path, sep='\t', dtype=str)
df.set_index('Unnamed: 0', inplace=True)
df
